// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `tagAlias.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __tagAlias_h__
#define __tagAlias_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/GCObject.h>
#include <Ice/AsyncResult.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 3
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace TagAlias
{

class TagAliasOp;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::TagAlias::TagAliasOp>&);
::IceProxy::Ice::Object* upCast(::IceProxy::TagAlias::TagAliasOp*);

class TagAliasOpAdd;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::TagAlias::TagAliasOpAdd>&);
::IceProxy::Ice::Object* upCast(::IceProxy::TagAlias::TagAliasOpAdd*);

}

}

namespace TagAlias
{

class TagAliasOp;
::Ice::Object* upCast(::TagAlias::TagAliasOp*);
typedef ::IceInternal::Handle< ::TagAlias::TagAliasOp> TagAliasOpPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::TagAlias::TagAliasOp> TagAliasOpPrx;
void __patch(TagAliasOpPtr&, const ::Ice::ObjectPtr&);

class TagAliasOpAdd;
::Ice::Object* upCast(::TagAlias::TagAliasOpAdd*);
typedef ::IceInternal::Handle< ::TagAlias::TagAliasOpAdd> TagAliasOpAddPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::TagAlias::TagAliasOpAdd> TagAliasOpAddPrx;
void __patch(TagAliasOpAddPtr&, const ::Ice::ObjectPtr&);

}

namespace TagAlias
{

class RequestCanceledException : public ::Ice::UserException
{
public:

    RequestCanceledException() {}
    virtual ~RequestCanceledException() throw();

    virtual ::std::string ice_name() const;
    virtual RequestCanceledException* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
};

static RequestCanceledException __RequestCanceledException_init;

typedef ::std::vector< ::Ice::Byte> bytes;

}

namespace Ice
{
template<>
struct StreamableTraits< ::TagAlias::RequestCanceledException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

}

namespace TagAlias
{

class AMD_TagAliasOp_request : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::std::string&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOp_request> AMD_TagAliasOp_requestPtr;

class AMD_TagAliasOp_request_next : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::std::string&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOp_request_next> AMD_TagAliasOp_request_nextPtr;

class AMD_TagAliasOp_getTaglist : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::TagAlias::bytes&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOp_getTaglist> AMD_TagAliasOp_getTaglistPtr;

class AMD_TagAliasOp_getUsersByTag : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::TagAlias::bytes&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOp_getUsersByTag> AMD_TagAliasOp_getUsersByTagPtr;

class AMD_TagAliasOp_getUsersByAlias : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::TagAlias::bytes&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOp_getUsersByAlias> AMD_TagAliasOp_getUsersByAliasPtr;

class AMD_TagAliasOp_getTagsByUser : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::TagAlias::bytes&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOp_getTagsByUser> AMD_TagAliasOp_getTagsByUserPtr;

class AMD_TagAliasOp_getAliasByUser : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::TagAlias::bytes&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOp_getAliasByUser> AMD_TagAliasOp_getAliasByUserPtr;

class AMD_TagAliasOp_checkUserBelongTag : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::TagAlias::bytes&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOp_checkUserBelongTag> AMD_TagAliasOp_checkUserBelongTagPtr;

class AMD_TagAliasOp_checkUserBelongAlias : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::TagAlias::bytes&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOp_checkUserBelongAlias> AMD_TagAliasOp_checkUserBelongAliasPtr;

class AMD_TagAliasOp_getUsersCountByTag : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::TagAlias::bytes&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOp_getUsersCountByTag> AMD_TagAliasOp_getUsersCountByTagPtr;

class AMD_TagAliasOp_getUsersCountByAlias : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::TagAlias::bytes&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOp_getUsersCountByAlias> AMD_TagAliasOp_getUsersCountByAliasPtr;

class AMD_TagAliasOp_validateTags : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::TagAlias::bytes&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOp_validateTags> AMD_TagAliasOp_validateTagsPtr;

class AMD_TagAliasOp_validateAlias : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::TagAlias::bytes&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOp_validateAlias> AMD_TagAliasOp_validateAliasPtr;

class AMD_TagAliasOpAdd_getTagsCountByUser : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::TagAlias::bytes&) = 0;
};

typedef ::IceUtil::Handle< ::TagAlias::AMD_TagAliasOpAdd_getTagsCountByUser> AMD_TagAliasOpAdd_getTagsCountByUserPtr;

}

namespace IceAsync
{

namespace TagAlias
{

class AMD_TagAliasOp_request : public ::TagAlias::AMD_TagAliasOp_request, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOp_request(::IceInternal::Incoming&);

    virtual void ice_response(const ::std::string&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TagAliasOp_request_next : public ::TagAlias::AMD_TagAliasOp_request_next, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOp_request_next(::IceInternal::Incoming&);

    virtual void ice_response(const ::std::string&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TagAliasOp_getTaglist : public ::TagAlias::AMD_TagAliasOp_getTaglist, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOp_getTaglist(::IceInternal::Incoming&);

    virtual void ice_response(const ::TagAlias::bytes&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TagAliasOp_getUsersByTag : public ::TagAlias::AMD_TagAliasOp_getUsersByTag, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOp_getUsersByTag(::IceInternal::Incoming&);

    virtual void ice_response(const ::TagAlias::bytes&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TagAliasOp_getUsersByAlias : public ::TagAlias::AMD_TagAliasOp_getUsersByAlias, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOp_getUsersByAlias(::IceInternal::Incoming&);

    virtual void ice_response(const ::TagAlias::bytes&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TagAliasOp_getTagsByUser : public ::TagAlias::AMD_TagAliasOp_getTagsByUser, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOp_getTagsByUser(::IceInternal::Incoming&);

    virtual void ice_response(const ::TagAlias::bytes&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TagAliasOp_getAliasByUser : public ::TagAlias::AMD_TagAliasOp_getAliasByUser, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOp_getAliasByUser(::IceInternal::Incoming&);

    virtual void ice_response(const ::TagAlias::bytes&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TagAliasOp_checkUserBelongTag : public ::TagAlias::AMD_TagAliasOp_checkUserBelongTag, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOp_checkUserBelongTag(::IceInternal::Incoming&);

    virtual void ice_response(const ::TagAlias::bytes&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TagAliasOp_checkUserBelongAlias : public ::TagAlias::AMD_TagAliasOp_checkUserBelongAlias, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOp_checkUserBelongAlias(::IceInternal::Incoming&);

    virtual void ice_response(const ::TagAlias::bytes&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TagAliasOp_getUsersCountByTag : public ::TagAlias::AMD_TagAliasOp_getUsersCountByTag, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOp_getUsersCountByTag(::IceInternal::Incoming&);

    virtual void ice_response(const ::TagAlias::bytes&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TagAliasOp_getUsersCountByAlias : public ::TagAlias::AMD_TagAliasOp_getUsersCountByAlias, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOp_getUsersCountByAlias(::IceInternal::Incoming&);

    virtual void ice_response(const ::TagAlias::bytes&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TagAliasOp_validateTags : public ::TagAlias::AMD_TagAliasOp_validateTags, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOp_validateTags(::IceInternal::Incoming&);

    virtual void ice_response(const ::TagAlias::bytes&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TagAliasOp_validateAlias : public ::TagAlias::AMD_TagAliasOp_validateAlias, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOp_validateAlias(::IceInternal::Incoming&);

    virtual void ice_response(const ::TagAlias::bytes&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

class AMD_TagAliasOpAdd_getTagsCountByUser : public ::TagAlias::AMD_TagAliasOpAdd_getTagsCountByUser, public ::IceInternal::IncomingAsync
{
public:

    AMD_TagAliasOpAdd_getTagsCountByUser(::IceInternal::Incoming&);

    virtual void ice_response(const ::TagAlias::bytes&);
    // COMPILERFIX: The using directive avoid compiler warnings with -Woverloaded-virtual
    using ::IceInternal::IncomingAsync::ice_exception;
    virtual void ice_exception(const ::std::exception&);
};

}

}

namespace TagAlias
{

class Callback_TagAliasOp_request_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_request_Base> Callback_TagAliasOp_requestPtr;

class Callback_TagAliasOp_request_next_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_request_next_Base> Callback_TagAliasOp_request_nextPtr;

class Callback_TagAliasOp_getTaglist_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_getTaglist_Base> Callback_TagAliasOp_getTaglistPtr;

class Callback_TagAliasOp_getUsersByTag_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_getUsersByTag_Base> Callback_TagAliasOp_getUsersByTagPtr;

class Callback_TagAliasOp_getUsersByAlias_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_getUsersByAlias_Base> Callback_TagAliasOp_getUsersByAliasPtr;

class Callback_TagAliasOp_getTagsByUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_getTagsByUser_Base> Callback_TagAliasOp_getTagsByUserPtr;

class Callback_TagAliasOp_getAliasByUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_getAliasByUser_Base> Callback_TagAliasOp_getAliasByUserPtr;

class Callback_TagAliasOp_checkUserBelongTag_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_checkUserBelongTag_Base> Callback_TagAliasOp_checkUserBelongTagPtr;

class Callback_TagAliasOp_checkUserBelongAlias_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_checkUserBelongAlias_Base> Callback_TagAliasOp_checkUserBelongAliasPtr;

class Callback_TagAliasOp_getUsersCountByTag_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_getUsersCountByTag_Base> Callback_TagAliasOp_getUsersCountByTagPtr;

class Callback_TagAliasOp_getUsersCountByAlias_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_getUsersCountByAlias_Base> Callback_TagAliasOp_getUsersCountByAliasPtr;

class Callback_TagAliasOp_validateTags_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_validateTags_Base> Callback_TagAliasOp_validateTagsPtr;

class Callback_TagAliasOp_validateAlias_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_validateAlias_Base> Callback_TagAliasOp_validateAliasPtr;

class Callback_TagAliasOp_shutdown_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOp_shutdown_Base> Callback_TagAliasOp_shutdownPtr;

class Callback_TagAliasOpAdd_getTagsCountByUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TagAliasOpAdd_getTagsCountByUser_Base> Callback_TagAliasOpAdd_getTagsCountByUserPtr;

}

namespace IceProxy
{

namespace TagAlias
{

class TagAliasOp : virtual public ::IceProxy::Ice::Object
{
public:

    void request(const ::std::string& __p_req, ::std::string& __p_res)
    {
        request(__p_req, __p_res, 0);
    }
    void request(const ::std::string& __p_req, ::std::string& __p_res, const ::Ice::Context& __ctx)
    {
        request(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_request(const ::std::string& __p_req, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_request(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_request(const ::std::string& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_request(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_request(const ::std::string& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_request(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_request(const ::std::string& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_request(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_request(const ::std::string& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_request(const ::std::string& __p_req)
    {
        return begin_request(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_request(const ::std::string& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_request(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_request(const ::std::string& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_request(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_request(const ::std::string& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_request(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_request(const ::std::string& __p_req, const ::TagAlias::Callback_TagAliasOp_requestPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_request(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_request(const ::std::string& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_requestPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_request(__p_req, &__ctx, __del, __cookie);
    }

    void end_request(::std::string& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void request(const ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_request(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void request_next(const ::std::string& __p_req, ::std::string& __p_res)
    {
        request_next(__p_req, __p_res, 0);
    }
    void request_next(const ::std::string& __p_req, ::std::string& __p_res, const ::Ice::Context& __ctx)
    {
        request_next(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_request_next(const ::std::string& __p_req, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_request_next(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_request_next(const ::std::string& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_request_next(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_request_next(const ::std::string& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_request_next(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_request_next(const ::std::string& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_request_next(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_request_next(const ::std::string& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_request_next(const ::std::string& __p_req)
    {
        return begin_request_next(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_request_next(const ::std::string& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_request_next(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_request_next(const ::std::string& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_request_next(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_request_next(const ::std::string& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_request_next(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_request_next(const ::std::string& __p_req, const ::TagAlias::Callback_TagAliasOp_request_nextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_request_next(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_request_next(const ::std::string& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_request_nextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_request_next(__p_req, &__ctx, __del, __cookie);
    }

    void end_request_next(::std::string& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void request_next(const ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_request_next(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void getTaglist(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res)
    {
        getTaglist(__p_req, __p_res, 0);
    }
    void getTaglist(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res, const ::Ice::Context& __ctx)
    {
        getTaglist(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getTaglist(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTaglist(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTaglist(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTaglist(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getTaglist(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTaglist(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTaglist(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTaglist(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getTaglist(const ::TagAlias::bytes& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getTaglist(const ::TagAlias::bytes& __p_req)
    {
        return begin_getTaglist(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTaglist(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_getTaglist(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTaglist(const ::TagAlias::bytes& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTaglist(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTaglist(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTaglist(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTaglist(const ::TagAlias::bytes& __p_req, const ::TagAlias::Callback_TagAliasOp_getTaglistPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTaglist(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTaglist(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_getTaglistPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTaglist(__p_req, &__ctx, __del, __cookie);
    }

    void end_getTaglist(::TagAlias::bytes& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void getTaglist(const ::TagAlias::bytes&, ::TagAlias::bytes&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTaglist(const ::TagAlias::bytes&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void getUsersByTag(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res)
    {
        getUsersByTag(__p_req, __p_res, 0);
    }
    void getUsersByTag(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res, const ::Ice::Context& __ctx)
    {
        getUsersByTag(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getUsersByTag(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUsersByTag(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUsersByTag(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUsersByTag(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getUsersByTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUsersByTag(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUsersByTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUsersByTag(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getUsersByTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getUsersByTag(const ::TagAlias::bytes& __p_req)
    {
        return begin_getUsersByTag(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUsersByTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_getUsersByTag(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUsersByTag(const ::TagAlias::bytes& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersByTag(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsersByTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersByTag(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsersByTag(const ::TagAlias::bytes& __p_req, const ::TagAlias::Callback_TagAliasOp_getUsersByTagPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersByTag(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsersByTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_getUsersByTagPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersByTag(__p_req, &__ctx, __del, __cookie);
    }

    void end_getUsersByTag(::TagAlias::bytes& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void getUsersByTag(const ::TagAlias::bytes&, ::TagAlias::bytes&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUsersByTag(const ::TagAlias::bytes&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void getUsersByAlias(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res)
    {
        getUsersByAlias(__p_req, __p_res, 0);
    }
    void getUsersByAlias(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res, const ::Ice::Context& __ctx)
    {
        getUsersByAlias(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getUsersByAlias(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUsersByAlias(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUsersByAlias(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUsersByAlias(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getUsersByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUsersByAlias(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUsersByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUsersByAlias(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getUsersByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getUsersByAlias(const ::TagAlias::bytes& __p_req)
    {
        return begin_getUsersByAlias(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUsersByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_getUsersByAlias(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUsersByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersByAlias(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsersByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersByAlias(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsersByAlias(const ::TagAlias::bytes& __p_req, const ::TagAlias::Callback_TagAliasOp_getUsersByAliasPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersByAlias(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsersByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_getUsersByAliasPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersByAlias(__p_req, &__ctx, __del, __cookie);
    }

    void end_getUsersByAlias(::TagAlias::bytes& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void getUsersByAlias(const ::TagAlias::bytes&, ::TagAlias::bytes&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUsersByAlias(const ::TagAlias::bytes&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void getTagsByUser(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res)
    {
        getTagsByUser(__p_req, __p_res, 0);
    }
    void getTagsByUser(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res, const ::Ice::Context& __ctx)
    {
        getTagsByUser(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getTagsByUser(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTagsByUser(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTagsByUser(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTagsByUser(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getTagsByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTagsByUser(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTagsByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTagsByUser(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getTagsByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getTagsByUser(const ::TagAlias::bytes& __p_req)
    {
        return begin_getTagsByUser(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTagsByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_getTagsByUser(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTagsByUser(const ::TagAlias::bytes& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTagsByUser(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTagsByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTagsByUser(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTagsByUser(const ::TagAlias::bytes& __p_req, const ::TagAlias::Callback_TagAliasOp_getTagsByUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTagsByUser(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTagsByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_getTagsByUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTagsByUser(__p_req, &__ctx, __del, __cookie);
    }

    void end_getTagsByUser(::TagAlias::bytes& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void getTagsByUser(const ::TagAlias::bytes&, ::TagAlias::bytes&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTagsByUser(const ::TagAlias::bytes&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void getAliasByUser(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res)
    {
        getAliasByUser(__p_req, __p_res, 0);
    }
    void getAliasByUser(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res, const ::Ice::Context& __ctx)
    {
        getAliasByUser(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getAliasByUser(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getAliasByUser(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getAliasByUser(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getAliasByUser(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getAliasByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getAliasByUser(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getAliasByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getAliasByUser(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getAliasByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getAliasByUser(const ::TagAlias::bytes& __p_req)
    {
        return begin_getAliasByUser(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAliasByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_getAliasByUser(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAliasByUser(const ::TagAlias::bytes& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAliasByUser(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAliasByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAliasByUser(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAliasByUser(const ::TagAlias::bytes& __p_req, const ::TagAlias::Callback_TagAliasOp_getAliasByUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAliasByUser(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAliasByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_getAliasByUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAliasByUser(__p_req, &__ctx, __del, __cookie);
    }

    void end_getAliasByUser(::TagAlias::bytes& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void getAliasByUser(const ::TagAlias::bytes&, ::TagAlias::bytes&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAliasByUser(const ::TagAlias::bytes&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void checkUserBelongTag(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res)
    {
        checkUserBelongTag(__p_req, __p_res, 0);
    }
    void checkUserBelongTag(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res, const ::Ice::Context& __ctx)
    {
        checkUserBelongTag(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_checkUserBelongTag(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_checkUserBelongTag(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_checkUserBelongTag(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_checkUserBelongTag(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_checkUserBelongTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_checkUserBelongTag(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_checkUserBelongTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_checkUserBelongTag(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_checkUserBelongTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_checkUserBelongTag(const ::TagAlias::bytes& __p_req)
    {
        return begin_checkUserBelongTag(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkUserBelongTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_checkUserBelongTag(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkUserBelongTag(const ::TagAlias::bytes& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkUserBelongTag(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkUserBelongTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkUserBelongTag(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkUserBelongTag(const ::TagAlias::bytes& __p_req, const ::TagAlias::Callback_TagAliasOp_checkUserBelongTagPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkUserBelongTag(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkUserBelongTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_checkUserBelongTagPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkUserBelongTag(__p_req, &__ctx, __del, __cookie);
    }

    void end_checkUserBelongTag(::TagAlias::bytes& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void checkUserBelongTag(const ::TagAlias::bytes&, ::TagAlias::bytes&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_checkUserBelongTag(const ::TagAlias::bytes&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void checkUserBelongAlias(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res)
    {
        checkUserBelongAlias(__p_req, __p_res, 0);
    }
    void checkUserBelongAlias(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res, const ::Ice::Context& __ctx)
    {
        checkUserBelongAlias(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_checkUserBelongAlias(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_checkUserBelongAlias(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_checkUserBelongAlias(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_checkUserBelongAlias(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_checkUserBelongAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_checkUserBelongAlias(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_checkUserBelongAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_checkUserBelongAlias(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_checkUserBelongAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_checkUserBelongAlias(const ::TagAlias::bytes& __p_req)
    {
        return begin_checkUserBelongAlias(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkUserBelongAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_checkUserBelongAlias(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkUserBelongAlias(const ::TagAlias::bytes& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkUserBelongAlias(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkUserBelongAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkUserBelongAlias(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkUserBelongAlias(const ::TagAlias::bytes& __p_req, const ::TagAlias::Callback_TagAliasOp_checkUserBelongAliasPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkUserBelongAlias(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_checkUserBelongAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_checkUserBelongAliasPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_checkUserBelongAlias(__p_req, &__ctx, __del, __cookie);
    }

    void end_checkUserBelongAlias(::TagAlias::bytes& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void checkUserBelongAlias(const ::TagAlias::bytes&, ::TagAlias::bytes&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_checkUserBelongAlias(const ::TagAlias::bytes&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void getUsersCountByTag(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res)
    {
        getUsersCountByTag(__p_req, __p_res, 0);
    }
    void getUsersCountByTag(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res, const ::Ice::Context& __ctx)
    {
        getUsersCountByTag(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getUsersCountByTag(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUsersCountByTag(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUsersCountByTag(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUsersCountByTag(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getUsersCountByTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUsersCountByTag(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUsersCountByTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUsersCountByTag(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getUsersCountByTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getUsersCountByTag(const ::TagAlias::bytes& __p_req)
    {
        return begin_getUsersCountByTag(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUsersCountByTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_getUsersCountByTag(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUsersCountByTag(const ::TagAlias::bytes& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersCountByTag(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsersCountByTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersCountByTag(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsersCountByTag(const ::TagAlias::bytes& __p_req, const ::TagAlias::Callback_TagAliasOp_getUsersCountByTagPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersCountByTag(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsersCountByTag(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_getUsersCountByTagPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersCountByTag(__p_req, &__ctx, __del, __cookie);
    }

    void end_getUsersCountByTag(::TagAlias::bytes& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void getUsersCountByTag(const ::TagAlias::bytes&, ::TagAlias::bytes&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUsersCountByTag(const ::TagAlias::bytes&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void getUsersCountByAlias(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res)
    {
        getUsersCountByAlias(__p_req, __p_res, 0);
    }
    void getUsersCountByAlias(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res, const ::Ice::Context& __ctx)
    {
        getUsersCountByAlias(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getUsersCountByAlias(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUsersCountByAlias(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUsersCountByAlias(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUsersCountByAlias(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getUsersCountByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUsersCountByAlias(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUsersCountByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUsersCountByAlias(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getUsersCountByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getUsersCountByAlias(const ::TagAlias::bytes& __p_req)
    {
        return begin_getUsersCountByAlias(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUsersCountByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_getUsersCountByAlias(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUsersCountByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersCountByAlias(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsersCountByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersCountByAlias(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsersCountByAlias(const ::TagAlias::bytes& __p_req, const ::TagAlias::Callback_TagAliasOp_getUsersCountByAliasPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersCountByAlias(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsersCountByAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_getUsersCountByAliasPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsersCountByAlias(__p_req, &__ctx, __del, __cookie);
    }

    void end_getUsersCountByAlias(::TagAlias::bytes& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void getUsersCountByAlias(const ::TagAlias::bytes&, ::TagAlias::bytes&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUsersCountByAlias(const ::TagAlias::bytes&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void validateTags(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res)
    {
        validateTags(__p_req, __p_res, 0);
    }
    void validateTags(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res, const ::Ice::Context& __ctx)
    {
        validateTags(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_validateTags(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_validateTags(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_validateTags(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_validateTags(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_validateTags(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_validateTags(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_validateTags(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_validateTags(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_validateTags(const ::TagAlias::bytes& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_validateTags(const ::TagAlias::bytes& __p_req)
    {
        return begin_validateTags(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_validateTags(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_validateTags(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_validateTags(const ::TagAlias::bytes& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_validateTags(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_validateTags(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_validateTags(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_validateTags(const ::TagAlias::bytes& __p_req, const ::TagAlias::Callback_TagAliasOp_validateTagsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_validateTags(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_validateTags(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_validateTagsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_validateTags(__p_req, &__ctx, __del, __cookie);
    }

    void end_validateTags(::TagAlias::bytes& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void validateTags(const ::TagAlias::bytes&, ::TagAlias::bytes&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_validateTags(const ::TagAlias::bytes&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void validateAlias(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res)
    {
        validateAlias(__p_req, __p_res, 0);
    }
    void validateAlias(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res, const ::Ice::Context& __ctx)
    {
        validateAlias(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_validateAlias(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_validateAlias(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_validateAlias(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_validateAlias(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_validateAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_validateAlias(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_validateAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_validateAlias(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_validateAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_validateAlias(const ::TagAlias::bytes& __p_req)
    {
        return begin_validateAlias(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_validateAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_validateAlias(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_validateAlias(const ::TagAlias::bytes& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_validateAlias(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_validateAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_validateAlias(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_validateAlias(const ::TagAlias::bytes& __p_req, const ::TagAlias::Callback_TagAliasOp_validateAliasPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_validateAlias(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_validateAlias(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_validateAliasPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_validateAlias(__p_req, &__ctx, __del, __cookie);
    }

    void end_validateAlias(::TagAlias::bytes& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void validateAlias(const ::TagAlias::bytes&, ::TagAlias::bytes&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_validateAlias(const ::TagAlias::bytes&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void shutdown()
    {
        shutdown(0);
    }
    void shutdown(const ::Ice::Context& __ctx)
    {
        shutdown(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_shutdown(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_shutdown(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_shutdown(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_shutdown(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_shutdown(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_shutdown()
    {
        return begin_shutdown(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx)
    {
        return begin_shutdown(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::TagAlias::Callback_TagAliasOp_shutdownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOp_shutdownPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_shutdown(&__ctx, __del, __cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr&);
    
private:

    void shutdown(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_secure(bool __secure) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_twoway() const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_oneway() const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_batchOneway() const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_datagram() const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_batchDatagram() const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_compress(bool __compress) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_timeout(int __timeout) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOp> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<TagAliasOp*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class TagAliasOpAdd : virtual public ::IceProxy::TagAlias::TagAliasOp
{
public:

    void getTagsCountByUser(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res)
    {
        getTagsCountByUser(__p_req, __p_res, 0);
    }
    void getTagsCountByUser(const ::TagAlias::bytes& __p_req, ::TagAlias::bytes& __p_res, const ::Ice::Context& __ctx)
    {
        getTagsCountByUser(__p_req, __p_res, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getTagsCountByUser(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTagsCountByUser(__p_req, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTagsCountByUser(const ::TagAlias::bytes& __p_req, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTagsCountByUser(__p_req, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getTagsCountByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getTagsCountByUser(__p_req, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getTagsCountByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getTagsCountByUser(__p_req, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getTagsCountByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::TagAlias::bytes&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getTagsCountByUser(const ::TagAlias::bytes& __p_req)
    {
        return begin_getTagsCountByUser(__p_req, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTagsCountByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx)
    {
        return begin_getTagsCountByUser(__p_req, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTagsCountByUser(const ::TagAlias::bytes& __p_req, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTagsCountByUser(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTagsCountByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTagsCountByUser(__p_req, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTagsCountByUser(const ::TagAlias::bytes& __p_req, const ::TagAlias::Callback_TagAliasOpAdd_getTagsCountByUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTagsCountByUser(__p_req, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getTagsCountByUser(const ::TagAlias::bytes& __p_req, const ::Ice::Context& __ctx, const ::TagAlias::Callback_TagAliasOpAdd_getTagsCountByUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getTagsCountByUser(__p_req, &__ctx, __del, __cookie);
    }

    void end_getTagsCountByUser(::TagAlias::bytes& __p_res, const ::Ice::AsyncResultPtr&);
    
private:

    void getTagsCountByUser(const ::TagAlias::bytes&, ::TagAlias::bytes&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getTagsCountByUser(const ::TagAlias::bytes&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_secure(bool __secure) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_twoway() const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_oneway() const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_batchOneway() const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_datagram() const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_batchDatagram() const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_compress(bool __compress) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_timeout(int __timeout) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<TagAliasOpAdd> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<TagAliasOpAdd*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace TagAlias
{

class TagAliasOp : virtual public ::Ice::Object
{
public:

    typedef TagAliasOpPrx ProxyType;
    typedef TagAliasOpPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void request_async(const ::TagAlias::AMD_TagAliasOp_requestPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___request(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void request_next_async(const ::TagAlias::AMD_TagAliasOp_request_nextPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___request_next(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getTaglist_async(const ::TagAlias::AMD_TagAliasOp_getTaglistPtr&, const ::TagAlias::bytes&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTaglist(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getUsersByTag_async(const ::TagAlias::AMD_TagAliasOp_getUsersByTagPtr&, const ::TagAlias::bytes&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUsersByTag(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getUsersByAlias_async(const ::TagAlias::AMD_TagAliasOp_getUsersByAliasPtr&, const ::TagAlias::bytes&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUsersByAlias(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getTagsByUser_async(const ::TagAlias::AMD_TagAliasOp_getTagsByUserPtr&, const ::TagAlias::bytes&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTagsByUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getAliasByUser_async(const ::TagAlias::AMD_TagAliasOp_getAliasByUserPtr&, const ::TagAlias::bytes&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAliasByUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void checkUserBelongTag_async(const ::TagAlias::AMD_TagAliasOp_checkUserBelongTagPtr&, const ::TagAlias::bytes&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___checkUserBelongTag(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void checkUserBelongAlias_async(const ::TagAlias::AMD_TagAliasOp_checkUserBelongAliasPtr&, const ::TagAlias::bytes&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___checkUserBelongAlias(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getUsersCountByTag_async(const ::TagAlias::AMD_TagAliasOp_getUsersCountByTagPtr&, const ::TagAlias::bytes&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUsersCountByTag(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getUsersCountByAlias_async(const ::TagAlias::AMD_TagAliasOp_getUsersCountByAliasPtr&, const ::TagAlias::bytes&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUsersCountByAlias(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void validateTags_async(const ::TagAlias::AMD_TagAliasOp_validateTagsPtr&, const ::TagAlias::bytes&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___validateTags(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void validateAlias_async(const ::TagAlias::AMD_TagAliasOp_validateAliasPtr&, const ::TagAlias::bytes&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___validateAlias(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void shutdown(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___shutdown(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const TagAliasOp& l, const TagAliasOp& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const TagAliasOp& l, const TagAliasOp& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class TagAliasOpAdd : virtual public ::TagAlias::TagAliasOp
{
public:

    typedef TagAliasOpAddPrx ProxyType;
    typedef TagAliasOpAddPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void getTagsCountByUser_async(const ::TagAlias::AMD_TagAliasOpAdd_getTagsCountByUserPtr&, const ::TagAlias::bytes&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getTagsCountByUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const TagAliasOpAdd& l, const TagAliasOpAdd& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const TagAliasOpAdd& l, const TagAliasOpAdd& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace TagAlias
{

template<class T>
class CallbackNC_TagAliasOp_request : public Callback_TagAliasOp_request_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_TagAliasOp_request(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::std::string res;
        try
        {
            __proxy->end_request(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOp_requestPtr
newCallback_TagAliasOp_request(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_request<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_requestPtr
newCallback_TagAliasOp_request(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_request<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_request : public Callback_TagAliasOp_request_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_TagAliasOp_request(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::std::string res;
        try
        {
            __proxy->end_request(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOp_requestPtr
newCallback_TagAliasOp_request(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_request<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_requestPtr
newCallback_TagAliasOp_request(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_request<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOp_request_next : public Callback_TagAliasOp_request_next_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_TagAliasOp_request_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::std::string res;
        try
        {
            __proxy->end_request_next(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOp_request_nextPtr
newCallback_TagAliasOp_request_next(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_request_next<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_request_nextPtr
newCallback_TagAliasOp_request_next(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_request_next<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_request_next : public Callback_TagAliasOp_request_next_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_TagAliasOp_request_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::std::string res;
        try
        {
            __proxy->end_request_next(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOp_request_nextPtr
newCallback_TagAliasOp_request_next(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_request_next<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_request_nextPtr
newCallback_TagAliasOp_request_next(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_request_next<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOp_getTaglist : public Callback_TagAliasOp_getTaglist_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::TagAlias::bytes&);

    CallbackNC_TagAliasOp_getTaglist(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getTaglist(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOp_getTaglistPtr
newCallback_TagAliasOp_getTaglist(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getTaglist<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_getTaglistPtr
newCallback_TagAliasOp_getTaglist(T* instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getTaglist<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_getTaglist : public Callback_TagAliasOp_getTaglist_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::TagAlias::bytes&, const CT&);

    Callback_TagAliasOp_getTaglist(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getTaglist(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOp_getTaglistPtr
newCallback_TagAliasOp_getTaglist(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getTaglist<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_getTaglistPtr
newCallback_TagAliasOp_getTaglist(T* instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getTaglist<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOp_getUsersByTag : public Callback_TagAliasOp_getUsersByTag_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::TagAlias::bytes&);

    CallbackNC_TagAliasOp_getUsersByTag(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getUsersByTag(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOp_getUsersByTagPtr
newCallback_TagAliasOp_getUsersByTag(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getUsersByTag<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_getUsersByTagPtr
newCallback_TagAliasOp_getUsersByTag(T* instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getUsersByTag<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_getUsersByTag : public Callback_TagAliasOp_getUsersByTag_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::TagAlias::bytes&, const CT&);

    Callback_TagAliasOp_getUsersByTag(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getUsersByTag(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOp_getUsersByTagPtr
newCallback_TagAliasOp_getUsersByTag(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getUsersByTag<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_getUsersByTagPtr
newCallback_TagAliasOp_getUsersByTag(T* instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getUsersByTag<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOp_getUsersByAlias : public Callback_TagAliasOp_getUsersByAlias_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::TagAlias::bytes&);

    CallbackNC_TagAliasOp_getUsersByAlias(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getUsersByAlias(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOp_getUsersByAliasPtr
newCallback_TagAliasOp_getUsersByAlias(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getUsersByAlias<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_getUsersByAliasPtr
newCallback_TagAliasOp_getUsersByAlias(T* instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getUsersByAlias<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_getUsersByAlias : public Callback_TagAliasOp_getUsersByAlias_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::TagAlias::bytes&, const CT&);

    Callback_TagAliasOp_getUsersByAlias(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getUsersByAlias(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOp_getUsersByAliasPtr
newCallback_TagAliasOp_getUsersByAlias(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getUsersByAlias<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_getUsersByAliasPtr
newCallback_TagAliasOp_getUsersByAlias(T* instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getUsersByAlias<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOp_getTagsByUser : public Callback_TagAliasOp_getTagsByUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::TagAlias::bytes&);

    CallbackNC_TagAliasOp_getTagsByUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getTagsByUser(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOp_getTagsByUserPtr
newCallback_TagAliasOp_getTagsByUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getTagsByUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_getTagsByUserPtr
newCallback_TagAliasOp_getTagsByUser(T* instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getTagsByUser<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_getTagsByUser : public Callback_TagAliasOp_getTagsByUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::TagAlias::bytes&, const CT&);

    Callback_TagAliasOp_getTagsByUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getTagsByUser(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOp_getTagsByUserPtr
newCallback_TagAliasOp_getTagsByUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getTagsByUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_getTagsByUserPtr
newCallback_TagAliasOp_getTagsByUser(T* instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getTagsByUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOp_getAliasByUser : public Callback_TagAliasOp_getAliasByUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::TagAlias::bytes&);

    CallbackNC_TagAliasOp_getAliasByUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getAliasByUser(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOp_getAliasByUserPtr
newCallback_TagAliasOp_getAliasByUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getAliasByUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_getAliasByUserPtr
newCallback_TagAliasOp_getAliasByUser(T* instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getAliasByUser<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_getAliasByUser : public Callback_TagAliasOp_getAliasByUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::TagAlias::bytes&, const CT&);

    Callback_TagAliasOp_getAliasByUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getAliasByUser(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOp_getAliasByUserPtr
newCallback_TagAliasOp_getAliasByUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getAliasByUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_getAliasByUserPtr
newCallback_TagAliasOp_getAliasByUser(T* instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getAliasByUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOp_checkUserBelongTag : public Callback_TagAliasOp_checkUserBelongTag_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::TagAlias::bytes&);

    CallbackNC_TagAliasOp_checkUserBelongTag(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_checkUserBelongTag(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOp_checkUserBelongTagPtr
newCallback_TagAliasOp_checkUserBelongTag(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_checkUserBelongTag<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_checkUserBelongTagPtr
newCallback_TagAliasOp_checkUserBelongTag(T* instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_checkUserBelongTag<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_checkUserBelongTag : public Callback_TagAliasOp_checkUserBelongTag_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::TagAlias::bytes&, const CT&);

    Callback_TagAliasOp_checkUserBelongTag(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_checkUserBelongTag(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOp_checkUserBelongTagPtr
newCallback_TagAliasOp_checkUserBelongTag(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_checkUserBelongTag<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_checkUserBelongTagPtr
newCallback_TagAliasOp_checkUserBelongTag(T* instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_checkUserBelongTag<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOp_checkUserBelongAlias : public Callback_TagAliasOp_checkUserBelongAlias_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::TagAlias::bytes&);

    CallbackNC_TagAliasOp_checkUserBelongAlias(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_checkUserBelongAlias(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOp_checkUserBelongAliasPtr
newCallback_TagAliasOp_checkUserBelongAlias(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_checkUserBelongAlias<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_checkUserBelongAliasPtr
newCallback_TagAliasOp_checkUserBelongAlias(T* instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_checkUserBelongAlias<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_checkUserBelongAlias : public Callback_TagAliasOp_checkUserBelongAlias_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::TagAlias::bytes&, const CT&);

    Callback_TagAliasOp_checkUserBelongAlias(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_checkUserBelongAlias(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOp_checkUserBelongAliasPtr
newCallback_TagAliasOp_checkUserBelongAlias(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_checkUserBelongAlias<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_checkUserBelongAliasPtr
newCallback_TagAliasOp_checkUserBelongAlias(T* instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_checkUserBelongAlias<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOp_getUsersCountByTag : public Callback_TagAliasOp_getUsersCountByTag_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::TagAlias::bytes&);

    CallbackNC_TagAliasOp_getUsersCountByTag(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getUsersCountByTag(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOp_getUsersCountByTagPtr
newCallback_TagAliasOp_getUsersCountByTag(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getUsersCountByTag<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_getUsersCountByTagPtr
newCallback_TagAliasOp_getUsersCountByTag(T* instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getUsersCountByTag<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_getUsersCountByTag : public Callback_TagAliasOp_getUsersCountByTag_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::TagAlias::bytes&, const CT&);

    Callback_TagAliasOp_getUsersCountByTag(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getUsersCountByTag(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOp_getUsersCountByTagPtr
newCallback_TagAliasOp_getUsersCountByTag(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getUsersCountByTag<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_getUsersCountByTagPtr
newCallback_TagAliasOp_getUsersCountByTag(T* instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getUsersCountByTag<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOp_getUsersCountByAlias : public Callback_TagAliasOp_getUsersCountByAlias_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::TagAlias::bytes&);

    CallbackNC_TagAliasOp_getUsersCountByAlias(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getUsersCountByAlias(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOp_getUsersCountByAliasPtr
newCallback_TagAliasOp_getUsersCountByAlias(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getUsersCountByAlias<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_getUsersCountByAliasPtr
newCallback_TagAliasOp_getUsersCountByAlias(T* instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_getUsersCountByAlias<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_getUsersCountByAlias : public Callback_TagAliasOp_getUsersCountByAlias_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::TagAlias::bytes&, const CT&);

    Callback_TagAliasOp_getUsersCountByAlias(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getUsersCountByAlias(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOp_getUsersCountByAliasPtr
newCallback_TagAliasOp_getUsersCountByAlias(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getUsersCountByAlias<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_getUsersCountByAliasPtr
newCallback_TagAliasOp_getUsersCountByAlias(T* instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_getUsersCountByAlias<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOp_validateTags : public Callback_TagAliasOp_validateTags_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::TagAlias::bytes&);

    CallbackNC_TagAliasOp_validateTags(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_validateTags(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOp_validateTagsPtr
newCallback_TagAliasOp_validateTags(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_validateTags<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_validateTagsPtr
newCallback_TagAliasOp_validateTags(T* instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_validateTags<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_validateTags : public Callback_TagAliasOp_validateTags_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::TagAlias::bytes&, const CT&);

    Callback_TagAliasOp_validateTags(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_validateTags(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOp_validateTagsPtr
newCallback_TagAliasOp_validateTags(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_validateTags<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_validateTagsPtr
newCallback_TagAliasOp_validateTags(T* instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_validateTags<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOp_validateAlias : public Callback_TagAliasOp_validateAlias_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::TagAlias::bytes&);

    CallbackNC_TagAliasOp_validateAlias(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_validateAlias(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOp_validateAliasPtr
newCallback_TagAliasOp_validateAlias(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_validateAlias<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_validateAliasPtr
newCallback_TagAliasOp_validateAlias(T* instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_validateAlias<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_validateAlias : public Callback_TagAliasOp_validateAlias_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::TagAlias::bytes&, const CT&);

    Callback_TagAliasOp_validateAlias(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpPrx __proxy = ::TagAlias::TagAliasOpPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_validateAlias(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOp_validateAliasPtr
newCallback_TagAliasOp_validateAlias(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_validateAlias<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_validateAliasPtr
newCallback_TagAliasOp_validateAlias(T* instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_validateAlias<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOp_shutdown : public Callback_TagAliasOp_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TagAliasOp_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_TagAliasOp_shutdownPtr
newCallback_TagAliasOp_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_shutdownPtr
newCallback_TagAliasOp_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_TagAliasOp_shutdownPtr
newCallback_TagAliasOp_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOp_shutdownPtr
newCallback_TagAliasOp_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOp_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOp_shutdown : public Callback_TagAliasOp_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TagAliasOp_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_TagAliasOp_shutdownPtr
newCallback_TagAliasOp_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_shutdownPtr
newCallback_TagAliasOp_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_shutdown<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_shutdownPtr
newCallback_TagAliasOp_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOp_shutdownPtr
newCallback_TagAliasOp_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOp_shutdown<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_TagAliasOpAdd_getTagsCountByUser : public Callback_TagAliasOpAdd_getTagsCountByUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::TagAlias::bytes&);

    CallbackNC_TagAliasOpAdd_getTagsCountByUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpAddPrx __proxy = ::TagAlias::TagAliasOpAddPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getTagsCountByUser(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(res);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_TagAliasOpAdd_getTagsCountByUserPtr
newCallback_TagAliasOpAdd_getTagsCountByUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOpAdd_getTagsCountByUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_TagAliasOpAdd_getTagsCountByUserPtr
newCallback_TagAliasOpAdd_getTagsCountByUser(T* instance, void (T::*cb)(const ::TagAlias::bytes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TagAliasOpAdd_getTagsCountByUser<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_TagAliasOpAdd_getTagsCountByUser : public Callback_TagAliasOpAdd_getTagsCountByUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::TagAlias::bytes&, const CT&);

    Callback_TagAliasOpAdd_getTagsCountByUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::TagAlias::TagAliasOpAddPrx __proxy = ::TagAlias::TagAliasOpAddPrx::uncheckedCast(__result->getProxy());
        ::TagAlias::bytes res;
        try
        {
            __proxy->end_getTagsCountByUser(res, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(res, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_TagAliasOpAdd_getTagsCountByUserPtr
newCallback_TagAliasOpAdd_getTagsCountByUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOpAdd_getTagsCountByUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_TagAliasOpAdd_getTagsCountByUserPtr
newCallback_TagAliasOpAdd_getTagsCountByUser(T* instance, void (T::*cb)(const ::TagAlias::bytes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TagAliasOpAdd_getTagsCountByUser<T, CT>(instance, cb, excb, sentcb);
}

}

#include <IceUtil/PopDisableWarnings.h>
#endif
